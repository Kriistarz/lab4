[отчет4лаба.md](https://github.com/user-attachments/files/23294643/4.md)
# Рязанова Кристина ИТ-8 Лабораторная №4

## Задание 1

### Задача 1.
Обобщенная коробка.
Создайте сущность Коробка, которая обладает следующими характеристиками:
 Может хранить один произвольный объект в один момент времени.
 Объект можно получить и разместить на хранение в любой момент времени.
 Если объект забирают из коробки – ссылку на этот объект необходимо обнулить.
 Если объект кладут в коробку, но она не пуста – необходимо выкинуть исключение.
 Имеет метод проверки на заполненность.
 Методы класса должны работать с тем типом данных, который был указан во время
создания объекта
Создайте Коробку которая может хранить целочисленное значение, разместите туда число 3.
Передайте Коробку в какой-либо метод, извлеките значение, и выведите его на экран.

#### Алгоритм решения

Сначала реализуется класс Box<T> с приватным полем value типа T, которое при создании инициализируется либо через
конструктор, либо по умолчанию равняется null. Для помещения объекта в коробку вызывается метод set(T value), который
первым делом проверяет, не заполнена ли коробка - если в поле value уже лежит объект, будет выброшено исключение с
объяснением, что коробка уже занята. Если коробка пуста, значение устанавливается. Метод get() сначала сохраняет текущее
содержимое value во временную переменную, далее обнуляет поле value и возвращает временное значение. Для проверки
статуса коробки есть метод isFilled(), возвращающий true, если объект присутствует. В тестах создается коробка типа
Integer, в нее помещается число 3, после чего число извлекается и во второй раз поле value уже будет пустым, что можно
проверить через вызов isFilled(). Если попытаться добавить второй объект, когда коробка не пуста, программа корректно
отработает ошибку.

<img width="407" height="141" alt="image" src="https://github.com/user-attachments/assets/629dbd9b-c2ec-4df7-83ee-8acc8ab43872" />

---

### Задача 2.
Без null.
Создайте сущность Хранилище, которая обладает следующими характеристиками:
 Может хранить один произвольный объект в один момент времени.
 Хранилище неизменяемо.
 Объект кладется в Хранилище при его создании. В качестве объекта может быть
сохранено также и значение null.
 Хранилище может вернуть ссылку на Объект.
 Если вместо объекта хранится null, необходимо вернуть какое-либо альтернативное
значение.
 Метод получения значения должен работать с тем типом данных, который был указан во
время создания объекта
Выполните следующие задания:
 Создайте Хранилище чисел, положите туда значение null. Передайте Хранилище в какойлибо метод, извлеките значение, и выведите его на экран. Альтернативой должно быть
число 0.
 Создайте Хранилище чисел, положите туда значение 99. Передайте Хранилище в какойлибо метод, извлеките значение, и выведите его на экран. Альтернативой должно быть
число -1.
 Создайте Хранилище строк, положите туда значение null. Передайте Хранилище в какойлибо метод, извлеките значение, и выведите его на экран. Альтернативой должна быть
строка “default”.
 Создайте Хранилище строк, положите туда значение “hello”. Передайте Хранилище в
какой-либо метод, извлеките значение, и выведите его на экран. Альтернативой должна
быть строка “hello world”.


#### Алгоритм решения

Для выполнения задачи реализуется неизменяемый класс Storage<T> с приватным неизменяемым полем value, инициализируемым
только через конструктор. После создания объекта его содержимое нельзя изменить. Нужно всегда возвратить
только то, что сохранено внутри, но если внутри null, то вернуть альтернативу, явно заданную пользователем. Для этого
реализован метод get(T defaultValue), который возвращает содержимое value, если оно не null, либо возвращает переданный
параметр defaultValue. В демонстрации решения создается объект Storage<Integer>, в который помещается null, а при
обращении с дефолтом 0 корректно возвращается 0. Аналогично для Storage<Integer> с числом 99 в качестве содержимого, при
обращении с дефолтом -1 возвращается именно 99. Для строк используем аналогичный механизм, создавая хранилище для null и
"hello" с разными альтернативами ("default", "hello world").

<img width="194" height="97" alt="image" src="https://github.com/user-attachments/assets/cb4a92b4-f76e-487a-bf5d-e9c1eef2f4c7" />
<img width="238" height="85" alt="image" src="https://github.com/user-attachments/assets/a4c35571-9cec-47ed-b409-e70aedec5a8d" />
<img width="229" height="94" alt="image" src="https://github.com/user-attachments/assets/4a17a8b8-ef35-49f5-bfe1-436b67101100" />
<img width="211" height="98" alt="image" src="https://github.com/user-attachments/assets/b3f4f4c7-3a35-4f10-b471-c34863d6e365" />







---

## Задание 2

### Задача 2.
Поиск максимума.
Создайте метод, принимающий набор Коробок из задачи 3.1.1 и возвращающий максимальное из
их значений в формате double. Принимаемые методом Коробки могут быть параметризованы
любыми видами чисел.


#### Алгоритм решения

В классе BoxUtil определяется статический метод maximum(List<Box<? extends Number>> boxes), который рассматривает список
коробок, содержащих числа различных типов. В начале значение извлекается из первой коробки и принимается за текущий
максимум. Далее в цикле перебираются оставшиеся коробки, и из каждой по методу get() извлекается значение; если в
результате преобразования к типу double текущий элемент оказывается больше максимума, максимум обновляется. После
завершения цикла метод возвращает максимальное число в виде типа double. 

<img width="226" height="95" alt="image" src="https://github.com/user-attachments/assets/d9329c5b-d596-4f44-8931-39b0fb001f5f" />

---

## Задание 3

### Задача 1. 
Функция.
Разработайте такой метод, который будет принимать список значений типа T, и объект имеющий
единственный метод apply. Данный метод надо применить к каждому элементу списка, и вернуть
новый список значений типа P, при этом типы T и P могут совпадать, а могут не совпадать.
Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями:“qwerty”, “asdfg”, “zx”, а получите список чисел,
где каждое число соответствует длине каждой строки.
2. Передайте в метод список со значениями: 1,-3,7, а получите список в котором все
отрицательные числа стали положительными, а положительные остались без изменений
3. Передайте в метод список состоящий из массивов целых чисел, а получите список в
котором будут только максимальные значения каждого из исходных массивов

#### Алгоритм решения

Для преобразования коллекций реализован универсальный метод transform(List<T> list, Function<T, P> func) внутри класса
TransformUtil. Внутри функции создается пустой результирующий список типа P. Далее функция func применяется поочередно к
каждому элементу исходного списка list, а результат добавляется в итоговый список. В примерах использования сначала
преобразуется список строк в длины этих строк, потом список целых чисел - в значения по модулю, а список массивов
целых чисел - в максимальное значение в каждом массиве.

<img width="277" height="162" alt="image" src="https://github.com/user-attachments/assets/835d10d9-d787-43d8-a018-48ae81e2401b" />

---

### Задача 2.
Фильтр.
Разработайте такой метод, который будет принимать список значений типа T и объект имеющий
единственный метод test (принимает T и возвращает boolean). Верните новый список типа T, из
которого удалены все значения не прошедшие проверку условием.
Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, и отфильтруйте все
строки имеющие менее трех символов
2. Передайте в метод список со значениями: 1,-3,7, и отфильтруйте все положительные
элементы
3. Передайте в метод список состоящий из массивов целых чисел, а получите список в
котором будут только те массивы, в которых нет ни одного положительного элемента


#### Алгоритм решения

Все элементы, удовлетворяющие заданному предикату, отбираются с помощью статического метода filter(List<T> list,
Predicate<T> condition) из класса FilterUtil. Итоговый список формируется путем последовательного перебора всех
элементов исходного и добавления только тех, для которых логическая функция condition возвращает true. Демонстрация
показывает, ято такое решение позволяет, например, выбрать из списка строк только те, у которых длина больше либо равна 3, отфильтровать из
списка целых чисел только отрицательные элементы либо взять только такие массивы целых чисел, в которых отсутствуют
положительные значения.

<img width="286" height="138" alt="image" src="https://github.com/user-attachments/assets/eb3eccaf-3c82-4a01-8656-a2d407a232ee" />

---

### Задача 3.
Сокращение.
Разработайте такой метод, который будет принимать список значений типа T и способ с помощью
которого список значений можно свести к одному значению типа T, которое и возвращается из
метода.
Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, и сформируйте одну
большую строку, которая состоит из всех строк исходного списка.
2. Передайте в метод список со значениями: 1,-3,7, и верните сумму всех значений исходного
списка.
3. Имеется список, состоящий из списков целых чисел, получите общеe количество
элементов во всех списках. Подсказка: решить задачу можно в одно действие или
последовательно использовать методы из 3.3.1 и 3.3.3.
Далее необходимо изменить разработанный метод таким образом, чтобы данный метод
гарантированно не возвращал null и не выбрасывал ошибок в том случае, если исходный список
пуст.

#### Алгоритм решения

Для сжатия или объединения элементов списка реализуется метод reduce(List<T> list, T identity, BinaryOperator<T>
reducer) класса Reducer. На входе указывается список, стартовое значение (или же значение на случай, если список окажется null), а также функция агрегации - со всеми этими
аргументами цикл по списку аккумулирует значения, последовательно присваивая результат промежуточной переменной. В
разные моменты можно конкатенировать строки (аккумулятор - пустая строка, функция - сложение), суммировать числа (
аккумулятор - 0, функция (референс на нее) - Integer::sum) или получать итоговое количество всех элементов вложенных коллекций.
Универсальность метода гарантируется тем, что даже для пустого списка на выходе всегда есть валидное значение (
identity).

<img width="289" height="164" alt="image" src="https://github.com/user-attachments/assets/7165fe70-764a-4345-805d-603cf67f4e59" />

---

### Задача 4.
Коллекционирование.
Разработайте такой метод, который будет возвращать коллекцию типа P со значениями типа T.
Данный метод будет принимать:
1. Список исходных значений
2. Способ создания результирующей коллекции
3. Способ передачи значений исходного списка в результирующую коллекцию.
Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями: 1,-3,7, и верните их разбитыми на два
подсписка, в одном из которых будут только положительные числа, а в другом только
отрицательные.
2. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, “qw” и верните их
разбитыми на подсписки таким образом, чтобы в любом подсписке были строки только
одинаковой длины
3. Передайте в метод список со значениями: “qwerty”, “asdfg”, “qwerty”, “qw” и верните набор
такого вида, который не может содержать одинаковые объекты.

#### Алгоритм решения

Для генерации агрегированных коллекций применяется универсальный статический метод collect(List<T> source, Supplier<P>
factory, BiConsumer<P, T> accumulator) из класса CollectorUtil. На первом шаге метод использует фабрику factory для
инициализации пустой коллекции целевого типа. Затем последовательным перебором всех элементов source каждый объект
добавляется в целевую коллекцию через переданную функцию accumulator. В итоге можно, например, сгруппировать числа на
положительные и отрицательные с помощью Map<String, List<Integer>>, распределить строки по длинам (Map<Integer,
List<String>>) или создать уникальное множество строк Set<String>

<img width="500" height="150" alt="image" src="https://github.com/user-attachments/assets/c13d976f-06c6-4922-b8e2-6d42ddb6bb4e" />

