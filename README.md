[отчет4лаба.md](https://github.com/user-attachments/files/23294643/4.md)
# Рязанова Кристина ИТ-8 Лабораторная №4

## Задание 1

### Задача 1. Обобщенная коробка

#### Алгоритм решения

Сначала реализуется класс Box<T> с приватным полем value типа T, которое при создании инициализируется либо через
конструктор, либо по умолчанию равняется null. Для помещения объекта в коробку вызывается метод set(T value), который
первым делом проверяет, не заполнена ли коробка - если в поле value уже лежит объект, будет выброшено исключение с
объяснением, что коробка уже занята. Если коробка пуста, значение устанавливается. Метод get() сначала сохраняет текущее
содержимое value во временную переменную, далее обнуляет поле value и возвращает временное значение. Для проверки
статуса коробки есть метод isFilled(), возвращающий true, если объект присутствует. В тестах создается коробка типа
Integer, в нее помещается число 3, после чего число извлекается и во второй раз поле value уже будет пустым, что можно
проверить через вызов isFilled(). Если попытаться добавить второй объект, когда коробка не пуста, программа корректно
отработает ошибку.


---

### Задача 2. Хранилище

#### Алгоритм решения

Для выполнения задачи реализуется неизменяемый класс Storage<T> с приватным неизменяемым полем value, инициализируемым
только через конструктор. После создания объекта его содержимое нельзя изменить. Нужно всегда возвратить
только то, что сохранено внутри, но если внутри null, то вернуть альтернативу, явно заданную пользователем. Для этого
реализован метод get(T defaultValue), который возвращает содержимое value, если оно не null, либо возвращает переданный
параметр defaultValue. В демонстрации решения создается объект Storage<Integer>, в который помещается null, а при
обращении с дефолтом 0 корректно возвращается 0. Аналогично для Storage<Integer> с числом 99 в качестве содержимого, при
обращении с дефолтом -1 возвращается именно 99. Для строк используем аналогичный механизм, создавая хранилище для null и
"hello" с разными альтернативами ("default", "hello world").

---

## Задание 2

### Задача 2. Поиск максимума

#### Алгоритм решения

В классе BoxUtil определяется статический метод maximum(List<Box<? extends Number>> boxes), который рассматривает список
коробок, содержащих числа различных типов. В начале значение извлекается из первой коробки и принимается за текущий
максимум. Далее в цикле перебираются оставшиеся коробки, и из каждой по методу get() извлекается значение; если в
результате преобразования к типу double текущий элемент оказывается больше максимума, максимум обновляется. После
завершения цикла метод возвращает максимальное число в виде типа double. В качестве теста используется список коробок с
числами
разных типов - Integer, Double, Float - что позволяет отражает корректную работу программы.

---

## Задание 3

### Задача 1. Функция

#### Алгоритм решения

Для преобразования коллекций реализован универсальный метод transform(List<T> list, Function<T, P> func) внутри класса
TransformUtil. Внутри функции создается пустой результирующий список типа P. Далее функция func применяется поочередно к
каждому элементу исходного списка list, а результат добавляется в итоговый список. В примерах использования сначала
преобразуется список строк в длины этих строк, потом список целых чисел - в значения по модулю, а список массивов
целых чисел - в максимальное значение в каждом массиве.

---

### Задача 2. Фильтрация

#### Алгоритм решения

Все элементы, удовлетворяющие заданному предикату, отбираются с помощью статического метода filter(List<T> list,
Predicate<T> condition) из класса FilterUtil. Итоговый список формируется путем последовательного перебора всех
элементов исходного и добавления только тех, для которых логическая функция condition возвращает true. Демонстрация
показывает, ято такое решение позволяет, например, выбрать из списка строк только те, у которых длина больше либо равна 3, отфильтровать из
списка целых чисел только отрицательные элементы либо взять только такие массивы целых чисел, в которых отсутствуют
положительные значения.

---

### Задача 3. Сокращение

#### Алгоритм решения

Для сжатия или объединения элементов списка реализуется метод reduce(List<T> list, T identity, BinaryOperator<T>
reducer) класса Reducer. На входе указывается список, стартовое значение (или же значение на случай, если список окажется null), а также функция агрегации - со всеми этими
аргументами цикл по списку аккумулирует значения, последовательно присваивая результат промежуточной переменной. В
разные моменты можно конкатенировать строки (аккумулятор - пустая строка, функция - сложение), суммировать числа (
аккумулятор - 0, функция (референс на нее) - Integer::sum) или получать итоговое количество всех элементов вложенных коллекций.
Универсальность метода гарантируется тем, что даже для пустого списка на выходе всегда есть валидное значение (
identity).

---

### Задача 4. Коллекционирование

#### Алгоритм решения

Для генерации агрегированных коллекций применяется универсальный статический метод collect(List<T> source, Supplier<P>
factory, BiConsumer<P, T> accumulator) из класса CollectorUtil. На первом шаге метод использует фабрику factory для
инициализации пустой коллекции целевого типа. Затем последовательным перебором всех элементов source каждый объект
добавляется в целевую коллекцию через переданную функцию accumulator. В итоге можно, например, сгруппировать числа на
положительные и отрицательные с помощью Map<String, List<Integer>>, распределить строки по длинам (Map<Integer,
List<String>>) или создать уникальное множество строк Set<String>
